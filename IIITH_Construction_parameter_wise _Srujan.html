<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Outdoor Data Visualization</title>
    <!-- Add Plotly.js library -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- Add styling -->
    <style>
      body {
        font-family: "Roboto", sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f3f3f3;
      }
      .plot-container {
        border: 2px solid #ddd;
        border-radius: 10px;
        background-color: rgb(255, 255, 255);
        margin: 20px;
      }
      h1 {
        color: #f6f7f8;
        text-align: center;
      }

      /* Responsive styles */
      @media only screen and (max-width: 600px) {
        .plot-container {
          margin: 10px;
        }
      }

      @media only screen and (min-width: 601px) {
        .plot-container {
          margin: 15px;
        }
      }

      .last-timestamp {
        text-align: center;
        margin-top: 10px;
        font-size: 14px;
      }

      .legend-container {
        position: absolute;
        top: 50px;
        right: 10px;
        background-color: rgba(255, 255, 255, 0.7);
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }

      .legend-item {
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <!-- Plotly Plot Containers -->
    <div id="mergedPlot1" class="plot-container"></div>
    <div id="mergedPlot2" class="plot-container"></div>
    <div id="mergedPlot3" class="plot-container"></div>
    <div id="mergedPlot4" class="plot-container"></div>
    <div id="mergedPlot5" class="plot-container"></div>

    <!-- Script for fetching and plotting data -->
    <script>
      // Function to fetch and plot data for a given channel and field
      function fetchDataAndPlot(channelId, apiKey, location, field) {
        const url = `https://api.thingspeak.com/channels/${channelId}/feeds.json?api_key=${apiKey}&results=10000`;

        return fetch(url)
          .then((response) => response.json())
          .then((data) => {
            const feeds = data.feeds;

            // Define start date and filter data from that date onwards
            const startDate = new Date("2025-08-27T00:00:00Z");
            const filteredFeeds = feeds.filter(
              (feed) => new Date(feed.created_at) >= startDate
            );

            // Group data into 5-second intervals
            const resampleInterval = 5000; // 5 seconds in milliseconds
            let groupedData = {};
            filteredFeeds.forEach((feed) => {
              const timestamp = new Date(feed.created_at).getTime();
              const interval = Math.floor(timestamp / resampleInterval) * resampleInterval;
              const val = parseFloat(feed[field]);
              if (!isNaN(val)) {
                if (!groupedData[interval]) {
                  groupedData[interval] = [];
                }
                groupedData[interval].push(val);
              }
            });

            // Create resampled timestamps and averaged values
            const timestamps = Object.keys(groupedData).map((interval) => {
              const date = new Date(parseInt(interval));
              // Adjust for IST (UTC +5:30)
              const istDate = new Date(date.getTime() + 5.5 * 60 * 60 * 1000);
              return istDate.toISOString().slice(0, 19).replace("T", " ");
            });

            const values = Object.values(groupedData).map(
              (group) => group.reduce((sum, value) => sum + value, 0) / group.length
            );

            // Create Plotly trace for the specified field
            return {
              x: timestamps,
              y: values,
              name: location,
              type: "scatter",
              mode: "lines",
            };
          })
          .catch((error) =>
            console.error(`Error fetching data for Channel ${location}:`, error)
          );
      }

      // ThingSpeak channels configurations
      const channelIds = [
        { id: "3045185", apiKey: "EIJUOIHKF8RZK3KA", label: "Node 1" },
        { id: "3045188", apiKey: "B1YBO3CROCZC02GV", label: "Node 2" },
        { id: "3045189", apiKey: "DROY0BNP5A20USMC", label: "Node 3" },
        { id: "3045192", apiKey: "MI3XQDOQ6WXJKB3P", label: "Node 4" },
      ];

      // Helper function to plot data for a field
      function plotField(field, containerId, title, yRange, yTitle) {
        const promises = channelIds.map((channel) =>
          fetchDataAndPlot(channel.id, channel.apiKey, channel.label, field)
        );

        Promise.all(promises)
          .then((traces) => {
            const layout = {
              title: title,
              xaxis: { title: "Timestamp", type: "category", rangeslider: { visible: true } },
              yaxis: { title: yTitle, range: yRange, tick0: yRange[0], dtick: 25 },
              showlegend: true,
              height: 750,
              width: 1250,
            };
            Plotly.newPlot(containerId, traces, layout);
          })
          .catch((error) => console.error(`Error fetching data for ${title}:`, error));
      }

      // Plot each parameter
      plotField("field1", "mergedPlot1", "Outdoor Data - Temperature (°C)", [0, 75], "Temperature (°C)");
      plotField("field2", "mergedPlot2", "Outdoor Data - Humidity (%)", [0, 100], "Humidity (%)");
      plotField("field3", "mergedPlot3", "Outdoor Data - PM2.5 (µg/m³)", [0, 1000], "PM2.5 (µg/m³)");
      plotField("field4", "mergedPlot4", "Outdoor Data - PM10 (µg/m³)", [0, 1000], "PM10 (µg/m³)");
      plotField("field5", "mergedPlot5", "Outdoor Data - Noise (dB)", [0, 130], "Noise (dB)");
    </script>
  </body>
</html>
